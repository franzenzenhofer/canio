// Generated by CoffeeScript 1.3.1
(function() {
  var ImageFilters, binarize, byArray, byImage, clamp, copy, dlog, flip, getToolbox, ifw, make, mirror, nb, newToolbox, rotateLeft, rotateRight, _DEBUG_,
    __slice = [].slice;

  ImageFilters = {};

  ImageFilters.utils = {
    initSampleCanvas: function() {
      var _canvas, _context;
      _canvas = document.createElement("canvas");
      _context = _canvas.getContext("2d");
      _canvas.width = 0;
      _canvas.height = 0;
      this.getSampleCanvas = function() {
        return _canvas;
      };
      this.getSampleContext = function() {
        return _context;
      };
      return this.createImageData = (_context.createImageData ? function(w, h) {
        return _context.createImageData(w, h);
      } : function(w, h) {
        return new ImageData(w, h);
      });
    },
    getSampleCanvas: function() {
      this.initSampleCanvas();
      return this.getSampleCanvas();
    },
    getSampleContext: function() {
      this.initSampleCanvas();
      return this.getSampleContext();
    },
    createImageData: function(w, h) {
      this.initSampleCanvas();
      return this.createImageData(w, h);
    },
    clamp: function(value) {
      if (value > 255) {
        return 255;
      } else {
        if (value < 0) {
          return 0;
        } else {
          return value;
        }
      }
    },
    buildMap: function(f) {
      var k, m, v;
      m = [];
      k = 0;
      v = void 0;
      while (k < 256) {
        m[k] = ((v = f(k)) > 255 ? 255 : (v < 0 ? 0 : v | 0));
        k += 1;
      }
      return m;
    },
    applyMap: function(src, dst, map) {
      var i, l, _results;
      i = 0;
      l = src.length;
      _results = [];
      while (i < l) {
        dst[i] = map[src[i]];
        dst[i + 1] = map[src[i + 1]];
        dst[i + 2] = map[src[i + 2]];
        dst[i + 3] = src[i + 3];
        _results.push(i += 4);
      }
      return _results;
    },
    mapRGB: function(src, dst, func) {
      return this.applyMap(src, dst, this.buildMap(func));
    },
    getPixelIndex: function(x, y, width, height, edge) {
      if (x < 0 || x >= width || y < 0 || y >= height) {
        switch (edge) {
          case 1:
            x = (x < 0 ? 0 : (x >= width ? width - 1 : x));
            y = (y < 0 ? 0 : (y >= height ? height - 1 : y));
            break;
          case 2:
            x = ((x %= width) < 0 ? x + width : x);
            y = ((y %= height) < 0 ? y + height : y);
            break;
          default:
            return null;
        }
      }
      return (y * width + x) << 2;
    },
    getPixel: function(src, x, y, width, height, edge) {
      var i;
      if (x < 0 || x >= width || y < 0 || y >= height) {
        switch (edge) {
          case 1:
            x = (x < 0 ? 0 : (x >= width ? width - 1 : x));
            y = (y < 0 ? 0 : (y >= height ? height - 1 : y));
            break;
          case 2:
            x = ((x %= width) < 0 ? x + width : x);
            y = ((y %= height) < 0 ? y + height : y);
            break;
          default:
            return 0;
        }
      }
      i = (y * width + x) << 2;
      return src[i + 3] << 24 | src[i] << 16 | src[i + 1] << 8 | src[i + 2];
    },
    getPixelByIndex: function(src, i) {
      return src[i + 3] << 24 | src[i] << 16 | src[i + 1] << 8 | src[i + 2];
    },
    copyBilinear: function(src, x, y, width, height, dst, dstIndex, edge) {
      var a, b, cx, cy, fx, fy, g, i, ne, nw, r, se, sw, wx, wy;
      fx = (x < 0 ? x - 1 | 0 : x | 0);
      fy = (y < 0 ? y - 1 | 0 : y | 0);
      wx = x - fx;
      wy = y - fy;
      i = void 0;
      nw = 0;
      ne = 0;
      sw = 0;
      se = 0;
      cx = void 0;
      cy = void 0;
      r = void 0;
      g = void 0;
      b = void 0;
      a = void 0;
      if (fx >= 0 && fx < (width - 1) && fy >= 0 && fy < (height - 1)) {
        i = (fy * width + fx) << 2;
        if (wx || wy) {
          nw = src[i + 3] << 24 | src[i] << 16 | src[i + 1] << 8 | src[i + 2];
          i += 4;
          ne = src[i + 3] << 24 | src[i] << 16 | src[i + 1] << 8 | src[i + 2];
          i = (i - 8) + (width << 2);
          sw = src[i + 3] << 24 | src[i] << 16 | src[i + 1] << 8 | src[i + 2];
          i += 4;
          se = src[i + 3] << 24 | src[i] << 16 | src[i + 1] << 8 | src[i + 2];
        } else {
          dst[dstIndex] = src[i];
          dst[dstIndex + 1] = src[i + 1];
          dst[dstIndex + 2] = src[i + 2];
          dst[dstIndex + 3] = src[i + 3];
          return;
        }
      } else {
        nw = this.getPixel(src, fx, fy, width, height, edge);
        if (wx || wy) {
          ne = this.getPixel(src, fx + 1, fy, width, height, edge);
          sw = this.getPixel(src, fx, fy + 1, width, height, edge);
          se = this.getPixel(src, fx + 1, fy + 1, width, height, edge);
        } else {
          dst[dstIndex] = nw >> 16 & 0xFF;
          dst[dstIndex + 1] = nw >> 8 & 0xFF;
          dst[dstIndex + 2] = nw & 0xFF;
          dst[dstIndex + 3] = nw >> 24 & 0xFF;
          return;
        }
      }
      cx = 1 - wx;
      cy = 1 - wy;
      r = ((nw >> 16 & 0xFF) * cx + (ne >> 16 & 0xFF) * wx) * cy + ((sw >> 16 & 0xFF) * cx + (se >> 16 & 0xFF) * wx) * wy;
      g = ((nw >> 8 & 0xFF) * cx + (ne >> 8 & 0xFF) * wx) * cy + ((sw >> 8 & 0xFF) * cx + (se >> 8 & 0xFF) * wx) * wy;
      b = ((nw & 0xFF) * cx + (ne & 0xFF) * wx) * cy + ((sw & 0xFF) * cx + (se & 0xFF) * wx) * wy;
      a = ((nw >> 24 & 0xFF) * cx + (ne >> 24 & 0xFF) * wx) * cy + ((sw >> 24 & 0xFF) * cx + (se >> 24 & 0xFF) * wx) * wy;
      dst[dstIndex] = (r > 255 ? 255 : (r < 0 ? 0 : r | 0));
      dst[dstIndex + 1] = (g > 255 ? 255 : (g < 0 ? 0 : g | 0));
      dst[dstIndex + 2] = (b > 255 ? 255 : (b < 0 ? 0 : b | 0));
      return dst[dstIndex + 3] = (a > 255 ? 255 : (a < 0 ? 0 : a | 0));
    },
    rgbToHsl: function(r, g, b) {
      var chroma, h, l, max, min, s;
      r /= 255;
      g /= 255;
      b /= 255;
      max = (r > g ? (r > b ? r : b) : (g > b ? g : b));
      min = (r < g ? (r < b ? r : b) : (g < b ? g : b));
      chroma = max - min;
      h = 0;
      s = 0;
      l = (min + max) / 2;
      if (chroma !== 0) {
        if (r === max) {
          h = (g - b) / chroma + (g < b ? 6 : 0);
        } else if (g === max) {
          h = (b - r) / chroma + 2;
        } else {
          h = (r - g) / chroma + 4;
        }
        h /= 6;
        s = (l > 0.5 ? chroma / (2 - max - min) : chroma / (max + min));
      }
      return [h, s, l];
    },
    hslToRgb: function(h, s, l) {
      var b, g, hue, i, m1, m2, r, rgb, tmp;
      m1 = void 0;
      m2 = void 0;
      hue = void 0;
      r = void 0;
      g = void 0;
      b = void 0;
      rgb = [];
      if (s === 0) {
        r = g = b = l * 255 + 0.5 | 0;
        rgb = [r, g, b];
      } else {
        if (l <= 0.5) {
          m2 = l * (s + 1);
        } else {
          m2 = l + s - l * s;
        }
        m1 = l * 2 - m2;
        hue = h + 1 / 3;
        tmp = void 0;
        i = 0;
        while (i < 3) {
          if (hue < 0) {
            hue += 1;
          } else {
            if (hue > 1) {
              hue -= 1;
            }
          }
          if (6 * hue < 1) {
            tmp = m1 + (m2 - m1) * hue * 6;
          } else if (2 * hue < 1) {
            tmp = m2;
          } else if (3 * hue < 2) {
            tmp = m1 + (m2 - m1) * (2 / 3 - hue) * 6;
          } else {
            tmp = m1;
          }
          rgb[i] = tmp * 255 + 0.5 | 0;
          hue -= 1 / 3;
          i += 1;
        }
      }
      return rgb;
    }
  };

  ImageFilters.Translate = function(srcImageData, x, y, interpolation) {};

  ImageFilters.Scale = function(srcImageData, scaleX, scaleY, interpolation) {};

  ImageFilters.Rotate = function(srcImageData, originX, originY, angle, resize, interpolation) {};

  ImageFilters.Affine = function(srcImageData, matrix, resize, interpolation) {};

  ImageFilters.UnsharpMask = function(srcImageData, level) {};

  ImageFilters.ConvolutionFilter = function(srcImageData, matrixX, matrixY, matrix, divisor, bias, preserveAlpha, clamp, color, alpha) {
    var a, b, clampA, clampB, clampG, clampR, col, colIndex, cols, dstImageData, dstPixels, g, index, m, mIndex, offset, p, r, replace, row, rowIndex, rows, srcHeight, srcLength, srcPixels, srcWidth, v, x, y;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    divisor = divisor || 1;
    bias = bias || 0;
    (preserveAlpha !== false) && (preserveAlpha = true);
    (clamp !== false) && (clamp = true);
    color = color || 0;
    alpha = alpha || 0;
    index = 0;
    rows = matrixX >> 1;
    cols = matrixY >> 1;
    clampR = color >> 16 & 0xFF;
    clampG = color >> 8 & 0xFF;
    clampB = color & 0xFF;
    clampA = alpha * 0xFF;
    y = 0;
    while (y < srcHeight) {
      x = 0;
      while (x < srcWidth) {
        r = 0;
        g = 0;
        b = 0;
        a = 0;
        replace = false;
        mIndex = 0;
        v = void 0;
        row = -rows;
        while (row <= rows) {
          rowIndex = y + row;
          offset = void 0;
          if (0 <= rowIndex && rowIndex < srcHeight) {
            offset = rowIndex * srcWidth;
          } else if (clamp) {
            offset = y * srcWidth;
          } else {
            replace = true;
          }
          col = -cols;
          while (col <= cols) {
            m = matrix[mIndex++];
            if (m !== 0) {
              colIndex = x + col;
              if (!(0 <= colIndex && colIndex < srcWidth)) {
                if (clamp) {
                  colIndex = x;
                } else {
                  replace = true;
                }
              }
              if (replace) {
                r += m * clampR;
                g += m * clampG;
                b += m * clampB;
                a += m * clampA;
              } else {
                p = (offset + colIndex) << 2;
                r += m * srcPixels[p];
                g += m * srcPixels[p + 1];
                b += m * srcPixels[p + 2];
                a += m * srcPixels[p + 3];
              }
            }
            col += 1;
          }
          row += 1;
        }
        dstPixels[index] = ((v = r / divisor + bias) > 255 ? 255 : (v < 0 ? 0 : v | 0));
        dstPixels[index + 1] = ((v = g / divisor + bias) > 255 ? 255 : (v < 0 ? 0 : v | 0));
        dstPixels[index + 2] = ((v = b / divisor + bias) > 255 ? 255 : (v < 0 ? 0 : v | 0));
        dstPixels[index + 3] = (preserveAlpha ? srcPixels[index + 3] : ((v = a / divisor + bias) > 255 ? 255 : (v < 0 ? 0 : v | 0)));
        x += 1;
        index += 4;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.Binarize = function(srcImageData, threshold) {
    var avg, dstImageData, dstPixels, i, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    if (isNaN(threshold)) {
      threshold = 0.5;
    }
    threshold *= 255;
    i = 0;
    while (i < srcLength) {
      avg = srcPixels[i] + srcPixels[i + 1] + srcPixels[i + 2] / 3;
      dstPixels[i] = dstPixels[i + 1] = dstPixels[i + 2] = (avg <= threshold ? 0 : 255);
      dstPixels[i + 3] = 255;
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.BlendAdd = function(srcImageData, blendImageData, dx, dy) {
    var blendPixels, dstImageData, dstPixels, i, srcHeight, srcLength, srcPixels, srcWidth, v;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    blendPixels = blendImageData.data;
    v = void 0;
    i = 0;
    while (i < srcLength) {
      dstPixels[i] = ((v = srcPixels[i] + blendPixels[i]) > 255 ? 255 : v);
      dstPixels[i + 1] = ((v = srcPixels[i + 1] + blendPixels[i + 1]) > 255 ? 255 : v);
      dstPixels[i + 2] = ((v = srcPixels[i + 2] + blendPixels[i + 2]) > 255 ? 255 : v);
      dstPixels[i + 3] = 255;
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.BlendSubtract = function(srcImageData, blendImageData, dx, dy) {
    var blendPixels, dstImageData, dstPixels, i, srcHeight, srcLength, srcPixels, srcWidth, v;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    blendPixels = blendImageData.data;
    v = void 0;
    i = 0;
    while (i < srcLength) {
      dstPixels[i] = ((v = srcPixels[i] - blendPixels[i]) < 0 ? 0 : v);
      dstPixels[i + 1] = ((v = srcPixels[i + 1] - blendPixels[i + 1]) < 0 ? 0 : v);
      dstPixels[i + 2] = ((v = srcPixels[i + 2] - blendPixels[i + 2]) < 0 ? 0 : v);
      dstPixels[i + 3] = 255;
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.BoxBlur = (function() {
    var blur;
    blur = function(src, dst, width, height, radius) {
      var a, b, dstIndex, g, i, l, next, nextIndex, p, prev, prevIndex, r, radiusPlus1, srcIndex, sumTable, tableSize, widthMinus1, x, y, _results;
      tableSize = radius * 2 + 1;
      radiusPlus1 = radius + 1;
      widthMinus1 = width - 1;
      r = void 0;
      g = void 0;
      b = void 0;
      a = void 0;
      srcIndex = 0;
      dstIndex = void 0;
      p = void 0;
      next = void 0;
      prev = void 0;
      i = void 0;
      l = void 0;
      x = void 0;
      y = void 0;
      nextIndex = void 0;
      prevIndex = void 0;
      sumTable = [];
      i = 0;
      l = 256 * tableSize;
      while (i < l) {
        sumTable[i] = i / tableSize | 0;
        i += 1;
      }
      y = 0;
      _results = [];
      while (y < height) {
        r = g = b = a = 0;
        dstIndex = y;
        p = srcIndex << 2;
        r += radiusPlus1 * src[p];
        g += radiusPlus1 * src[p + 1];
        b += radiusPlus1 * src[p + 2];
        a += radiusPlus1 * src[p + 3];
        i = 1;
        while (i <= radius) {
          p = (srcIndex + (i < width ? i : widthMinus1)) << 2;
          r += src[p];
          g += src[p + 1];
          b += src[p + 2];
          a += src[p + 3];
          i += 1;
        }
        x = 0;
        while (x < width) {
          p = dstIndex << 2;
          dst[p] = sumTable[r];
          dst[p + 1] = sumTable[g];
          dst[p + 2] = sumTable[b];
          dst[p + 3] = sumTable[a];
          nextIndex = x + radiusPlus1;
          if (nextIndex > widthMinus1) {
            nextIndex = widthMinus1;
          }
          prevIndex = x - radius;
          if (prevIndex < 0) {
            prevIndex = 0;
          }
          next = (srcIndex + nextIndex) << 2;
          prev = (srcIndex + prevIndex) << 2;
          r += src[next] - src[prev];
          g += src[next + 1] - src[prev + 1];
          b += src[next + 2] - src[prev + 2];
          a += src[next + 3] - src[prev + 3];
          dstIndex += height;
          x += 1;
        }
        srcIndex += width;
        _results.push(y += 1);
      }
      return _results;
    };
    return function(srcImageData, hRadius, vRadius, quality) {
      var dstImageData, dstPixels, i, srcHeight, srcLength, srcPixels, srcWidth, tmpImageData, tmpPixels;
      srcPixels = srcImageData.data;
      srcWidth = srcImageData.width;
      srcHeight = srcImageData.height;
      srcLength = srcPixels.length;
      dstImageData = this.utils.createImageData(srcWidth, srcHeight);
      dstPixels = dstImageData.data;
      tmpImageData = this.utils.createImageData(srcWidth, srcHeight);
      tmpPixels = tmpImageData.data;
      i = 0;
      while (i < quality) {
        blur((i ? dstPixels : srcPixels), tmpPixels, srcWidth, srcHeight, hRadius);
        blur(tmpPixels, dstPixels, srcHeight, srcWidth, vRadius);
        i += 1;
      }
      return dstImageData;
    };
  })();

  ImageFilters.GaussianBlur = function(srcImageData, strength) {
    var divisor, matrix, size;
    size = void 0;
    matrix = void 0;
    divisor = void 0;
    switch (strength) {
      case 2:
        size = 5;
        matrix = [1, 1, 2, 1, 1, 1, 2, 4, 2, 1, 2, 4, 8, 4, 2, 1, 2, 4, 2, 1, 1, 1, 2, 1, 1];
        divisor = 52;
        break;
      case 3:
        size = 7;
        matrix = [1, 1, 2, 2, 2, 1, 1, 1, 2, 2, 4, 2, 2, 1, 2, 2, 4, 8, 4, 2, 2, 2, 4, 8, 16, 8, 4, 2, 2, 2, 4, 8, 4, 2, 2, 1, 2, 2, 4, 2, 2, 1, 1, 1, 2, 2, 2, 1, 1];
        divisor = 140;
        break;
      case 4:
        size = 15;
        matrix = [2, 2, 3, 4, 5, 5, 6, 6, 6, 5, 5, 4, 3, 2, 2, 2, 3, 4, 5, 7, 7, 8, 8, 8, 7, 7, 5, 4, 3, 2, 3, 4, 6, 7, 9, 10, 10, 11, 10, 10, 9, 7, 6, 4, 3, 4, 5, 7, 9, 10, 12, 13, 13, 13, 12, 10, 9, 7, 5, 4, 5, 7, 9, 11, 13, 14, 15, 16, 15, 14, 13, 11, 9, 7, 5, 5, 7, 10, 12, 14, 16, 17, 18, 17, 16, 14, 12, 10, 7, 5, 6, 8, 10, 13, 15, 17, 19, 19, 19, 17, 15, 13, 10, 8, 6, 6, 8, 11, 13, 16, 18, 19, 20, 19, 18, 16, 13, 11, 8, 6, 6, 8, 10, 13, 15, 17, 19, 19, 19, 17, 15, 13, 10, 8, 6, 5, 7, 10, 12, 14, 16, 17, 18, 17, 16, 14, 12, 10, 7, 5, 5, 7, 9, 11, 13, 14, 15, 16, 15, 14, 13, 11, 9, 7, 5, 4, 5, 7, 9, 10, 12, 13, 13, 13, 12, 10, 9, 7, 5, 4, 3, 4, 6, 7, 9, 10, 10, 11, 10, 10, 9, 7, 6, 4, 3, 2, 3, 4, 5, 7, 7, 8, 8, 8, 7, 7, 5, 4, 3, 2, 2, 2, 3, 4, 5, 5, 6, 6, 6, 5, 5, 4, 3, 2, 2];
        divisor = 2044;
        break;
      default:
        size = 3;
        matrix = [1, 2, 1, 2, 4, 2, 1, 2, 1];
        divisor = 16;
    }
    return ImageFilters.ConvolutionFilter(srcImageData, size, size, matrix, divisor, 0, false);
  };

  ImageFilters.StackBlur = (function() {
    var BlurStack, mul_table, shg_table;
    BlurStack = function() {
      this.r = 0;
      this.g = 0;
      this.b = 0;
      this.a = 0;
      return this.next = null;
    };
    mul_table = [512, 512, 456, 512, 328, 456, 335, 512, 405, 328, 271, 456, 388, 335, 292, 512, 454, 405, 364, 328, 298, 271, 496, 456, 420, 388, 360, 335, 312, 292, 273, 512, 482, 454, 428, 405, 383, 364, 345, 328, 312, 298, 284, 271, 259, 496, 475, 456, 437, 420, 404, 388, 374, 360, 347, 335, 323, 312, 302, 292, 282, 273, 265, 512, 497, 482, 468, 454, 441, 428, 417, 405, 394, 383, 373, 364, 354, 345, 337, 328, 320, 312, 305, 298, 291, 284, 278, 271, 265, 259, 507, 496, 485, 475, 465, 456, 446, 437, 428, 420, 412, 404, 396, 388, 381, 374, 367, 360, 354, 347, 341, 335, 329, 323, 318, 312, 307, 302, 297, 292, 287, 282, 278, 273, 269, 265, 261, 512, 505, 497, 489, 482, 475, 468, 461, 454, 447, 441, 435, 428, 422, 417, 411, 405, 399, 394, 389, 383, 378, 373, 368, 364, 359, 354, 350, 345, 341, 337, 332, 328, 324, 320, 316, 312, 309, 305, 301, 298, 294, 291, 287, 284, 281, 278, 274, 271, 268, 265, 262, 259, 257, 507, 501, 496, 491, 485, 480, 475, 470, 465, 460, 456, 451, 446, 442, 437, 433, 428, 424, 420, 416, 412, 408, 404, 400, 396, 392, 388, 385, 381, 377, 374, 370, 367, 363, 360, 357, 354, 350, 347, 344, 341, 338, 335, 332, 329, 326, 323, 320, 318, 315, 312, 310, 307, 304, 302, 299, 297, 294, 292, 289, 287, 285, 282, 280, 278, 275, 273, 271, 269, 267, 265, 263, 261, 259];
    shg_table = [9, 11, 12, 13, 13, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24];
    return function(srcImageData, radius) {
      var a_in_sum, a_out_sum, a_sum, b_in_sum, b_out_sum, b_sum, div, dstImageData, dstPixels, g_in_sum, g_out_sum, g_sum, heightMinus1, i, mul_sum, p, pa, pb, pg, pr, r_in_sum, r_out_sum, r_sum, radiusPlus1, rbs, shg_sum, srcHeight, srcLength, srcPixels, srcWidth, stack, stackEnd, stackIn, stackOut, stackStart, sumFactor, w4, widthMinus1, x, y, yi, yp, yw;
      srcPixels = srcImageData.data;
      srcWidth = srcImageData.width;
      srcHeight = srcImageData.height;
      srcLength = srcPixels.length;
      dstImageData = this.Clone(srcImageData);
      dstPixels = dstImageData.data;
      x = void 0;
      y = void 0;
      i = void 0;
      p = void 0;
      yp = void 0;
      yi = void 0;
      yw = void 0;
      r_sum = void 0;
      g_sum = void 0;
      b_sum = void 0;
      a_sum = void 0;
      r_out_sum = void 0;
      g_out_sum = void 0;
      b_out_sum = void 0;
      a_out_sum = void 0;
      r_in_sum = void 0;
      g_in_sum = void 0;
      b_in_sum = void 0;
      a_in_sum = void 0;
      pr = void 0;
      pg = void 0;
      pb = void 0;
      pa = void 0;
      rbs = void 0;
      div = radius + radius + 1;
      w4 = srcWidth << 2;
      widthMinus1 = srcWidth - 1;
      heightMinus1 = srcHeight - 1;
      radiusPlus1 = radius + 1;
      sumFactor = radiusPlus1 * (radiusPlus1 + 1) / 2;
      stackStart = new BlurStack();
      stack = stackStart;
      stackIn = void 0;
      stackOut = void 0;
      stackEnd = void 0;
      mul_sum = mul_table[radius];
      shg_sum = shg_table[radius];
      i = 1;
      while (i < div) {
        stack = stack.next = new BlurStack();
        if (i === radiusPlus1) {
          stackEnd = stack;
        }
        i += 1;
      }
      stack.next = stackStart;
      yw = yi = 0;
      y = 0;
      while (y < srcHeight) {
        r_in_sum = g_in_sum = b_in_sum = a_in_sum = r_sum = g_sum = b_sum = a_sum = 0;
        r_out_sum = radiusPlus1 * (pr = dstPixels[yi]);
        g_out_sum = radiusPlus1 * (pg = dstPixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = dstPixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = dstPixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        i = 0;
        while (i < radiusPlus1) {
          stack.r = pr;
          stack.g = pg;
          stack.b = pb;
          stack.a = pa;
          stack = stack.next;
          i += 1;
        }
        i = 1;
        while (i < radiusPlus1) {
          p = yi + ((widthMinus1 < i ? widthMinus1 : i) << 2);
          r_sum += (stack.r = (pr = dstPixels[p])) * (rbs = radiusPlus1 - i);
          g_sum += (stack.g = (pg = dstPixels[p + 1])) * rbs;
          b_sum += (stack.b = (pb = dstPixels[p + 2])) * rbs;
          a_sum += (stack.a = (pa = dstPixels[p + 3])) * rbs;
          r_in_sum += pr;
          g_in_sum += pg;
          b_in_sum += pb;
          a_in_sum += pa;
          stack = stack.next;
          i += 1;
        }
        stackIn = stackStart;
        stackOut = stackEnd;
        x = 0;
        while (x < srcWidth) {
          dstPixels[yi] = (r_sum * mul_sum) >> shg_sum;
          dstPixels[yi + 1] = (g_sum * mul_sum) >> shg_sum;
          dstPixels[yi + 2] = (b_sum * mul_sum) >> shg_sum;
          dstPixels[yi + 3] = (a_sum * mul_sum) >> shg_sum;
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          p = (yw + ((p = x + radius + 1) < widthMinus1 ? p : widthMinus1)) << 2;
          r_in_sum += (stackIn.r = dstPixels[p]);
          g_in_sum += (stackIn.g = dstPixels[p + 1]);
          b_in_sum += (stackIn.b = dstPixels[p + 2]);
          a_in_sum += (stackIn.a = dstPixels[p + 3]);
          r_sum += r_in_sum;
          g_sum += g_in_sum;
          b_sum += b_in_sum;
          a_sum += a_in_sum;
          stackIn = stackIn.next;
          r_out_sum += (pr = stackOut.r);
          g_out_sum += (pg = stackOut.g);
          b_out_sum += (pb = stackOut.b);
          a_out_sum += (pa = stackOut.a);
          r_in_sum -= pr;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackOut = stackOut.next;
          yi += 4;
          x += 1;
        }
        yw += srcWidth;
        y += 1;
      }
      x = 0;
      while (x < srcWidth) {
        g_in_sum = b_in_sum = a_in_sum = r_in_sum = g_sum = b_sum = a_sum = r_sum = 0;
        yi = x << 2;
        r_out_sum = radiusPlus1 * (pr = dstPixels[yi]);
        g_out_sum = radiusPlus1 * (pg = dstPixels[yi + 1]);
        b_out_sum = radiusPlus1 * (pb = dstPixels[yi + 2]);
        a_out_sum = radiusPlus1 * (pa = dstPixels[yi + 3]);
        r_sum += sumFactor * pr;
        g_sum += sumFactor * pg;
        b_sum += sumFactor * pb;
        a_sum += sumFactor * pa;
        stack = stackStart;
        i = 0;
        while (i < radiusPlus1) {
          stack.r = pr;
          stack.g = pg;
          stack.b = pb;
          stack.a = pa;
          stack = stack.next;
          i += 1;
        }
        yp = srcWidth;
        i = 1;
        while (i <= radius) {
          yi = (yp + x) << 2;
          r_sum += (stack.r = (pr = dstPixels[yi])) * (rbs = radiusPlus1 - i);
          g_sum += (stack.g = (pg = dstPixels[yi + 1])) * rbs;
          b_sum += (stack.b = (pb = dstPixels[yi + 2])) * rbs;
          a_sum += (stack.a = (pa = dstPixels[yi + 3])) * rbs;
          r_in_sum += pr;
          g_in_sum += pg;
          b_in_sum += pb;
          a_in_sum += pa;
          stack = stack.next;
          if (i < heightMinus1) {
            yp += srcWidth;
          }
          i += 1;
        }
        yi = x;
        stackIn = stackStart;
        stackOut = stackEnd;
        y = 0;
        while (y < srcHeight) {
          p = yi << 2;
          dstPixels[p] = (r_sum * mul_sum) >> shg_sum;
          dstPixels[p + 1] = (g_sum * mul_sum) >> shg_sum;
          dstPixels[p + 2] = (b_sum * mul_sum) >> shg_sum;
          dstPixels[p + 3] = (a_sum * mul_sum) >> shg_sum;
          r_sum -= r_out_sum;
          g_sum -= g_out_sum;
          b_sum -= b_out_sum;
          a_sum -= a_out_sum;
          r_out_sum -= stackIn.r;
          g_out_sum -= stackIn.g;
          b_out_sum -= stackIn.b;
          a_out_sum -= stackIn.a;
          p = (x + (((p = y + radiusPlus1) < heightMinus1 ? p : heightMinus1) * srcWidth)) << 2;
          r_sum += (r_in_sum += (stackIn.r = dstPixels[p]));
          g_sum += (g_in_sum += (stackIn.g = dstPixels[p + 1]));
          b_sum += (b_in_sum += (stackIn.b = dstPixels[p + 2]));
          a_sum += (a_in_sum += (stackIn.a = dstPixels[p + 3]));
          stackIn = stackIn.next;
          r_out_sum += (pr = stackOut.r);
          g_out_sum += (pg = stackOut.g);
          b_out_sum += (pb = stackOut.b);
          a_out_sum += (pa = stackOut.a);
          r_in_sum -= pr;
          g_in_sum -= pg;
          b_in_sum -= pb;
          a_in_sum -= pa;
          stackOut = stackOut.next;
          yi += srcWidth;
          y += 1;
        }
        x += 1;
      }
      return dstImageData;
    };
  })();

  ImageFilters.Brightness = function(srcImageData, brightness) {
    var dstImageData, dstPixels, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      value += brightness;
      if (value > 255) {
        return 255;
      } else {
        return value;
      }
    });
    return dstImageData;
  };

  ImageFilters.BrightnessContrastGimp = function(srcImageData, brightness, contrast) {
    var avg, dstImageData, dstPixels, i, p4, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    p4 = Math.PI / 4;
    brightness /= 100;
    contrast *= 0.99;
    contrast /= 100;
    contrast = Math.tan((contrast + 1) * p4);
    avg = 0;
    i = 0;
    while (i < srcLength) {
      avg += (srcPixels[i] * 19595 + srcPixels[i + 1] * 38470 + srcPixels[i + 2] * 7471) >> 16;
      i += 4;
    }
    avg = avg / (srcLength / 4);
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      if (brightness < 0) {
        value = value * (1 + brightness);
      } else {
        if (brightness > 0) {
          value = value + ((255 - value) * brightness);
        }
      }
      if (contrast !== 0) {
        value = (value - avg) * contrast + avg;
      }
      return value + 0.5 | 0;
    });
    return dstImageData;
  };

  ImageFilters.BrightnessContrastPhotoshop = function(srcImageData, brightness, contrast) {
    var dstImageData, dstPixels, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    brightness = (brightness + 100) / 100;
    contrast = (contrast + 100) / 100;
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      value *= brightness;
      value = (value - 127.5) * contrast + 127.5;
      return value + 0.5 | 0;
    });
    return dstImageData;
  };

  ImageFilters.Channels = function(srcImageData, channel) {
    var matrix;
    matrix = void 0;
    switch (channel) {
      case 2:
        matrix = [0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0];
        break;
      case 3:
        matrix = [0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        break;
      default:
        matrix = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
    }
    return this.ColorMatrixFilter(srcImageData, matrix);
  };

  ImageFilters.Clone = function(srcImageData) {
    return this.Copy(srcImageData, this.utils.createImageData(srcImageData.width, srcImageData.height));
  };

  ImageFilters.CloneBuiltin = function(srcImageData) {
    var canvas, context, dstImageData, srcHeight, srcWidth;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    canvas = this.utils.getSampleCanvas();
    context = this.utils.getSampleContext();
    dstImageData = void 0;
    canvas.width = srcWidth;
    canvas.height = srcHeight;
    context.putImageData(srcImageData, 0, 0);
    dstImageData = context.getImageData(0, 0, srcWidth, srcHeight);
    canvas.width = 0;
    canvas.height = 0;
    return dstImageData;
  };

  ImageFilters.ColorMatrixFilter = function(srcImageData, matrix) {
    var a, b, dstImageData, dstPixels, g, i, m0, m1, m10, m11, m12, m13, m14, m15, m16, m17, m18, m19, m2, m3, m4, m5, m6, m7, m8, m9, r, srcHeight, srcLength, srcPixels, srcWidth, value;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    m0 = matrix[0];
    m1 = matrix[1];
    m2 = matrix[2];
    m3 = matrix[3];
    m4 = matrix[4];
    m5 = matrix[5];
    m6 = matrix[6];
    m7 = matrix[7];
    m8 = matrix[8];
    m9 = matrix[9];
    m10 = matrix[10];
    m11 = matrix[11];
    m12 = matrix[12];
    m13 = matrix[13];
    m14 = matrix[14];
    m15 = matrix[15];
    m16 = matrix[16];
    m17 = matrix[17];
    m18 = matrix[18];
    m19 = matrix[19];
    value = void 0;
    i = void 0;
    r = void 0;
    g = void 0;
    b = void 0;
    a = void 0;
    i = 0;
    while (i < srcLength) {
      r = srcPixels[i];
      g = srcPixels[i + 1];
      b = srcPixels[i + 2];
      a = srcPixels[i + 3];
      dstPixels[i] = ((value = r * m0 + g * m1 + b * m2 + a * m3 + m4) > 255 ? 255 : (value < 0 ? 0 : value | 0));
      dstPixels[i + 1] = ((value = r * m5 + g * m6 + b * m7 + a * m8 + m9) > 255 ? 255 : (value < 0 ? 0 : value | 0));
      dstPixels[i + 2] = ((value = r * m10 + g * m11 + b * m12 + a * m13 + m14) > 255 ? 255 : (value < 0 ? 0 : value | 0));
      dstPixels[i + 3] = ((value = r * m15 + g * m16 + b * m17 + a * m18 + m19) > 255 ? 255 : (value < 0 ? 0 : value | 0));
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.ColorTransformFilter = function(srcImageData, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
    var dstImageData, dstPixels, i, srcHeight, srcLength, srcPixels, srcWidth, v;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    i = void 0;
    v = void 0;
    i = 0;
    while (i < srcLength) {
      dstPixels[i] = ((v = srcPixels[i] * redMultiplier + redOffset) > 255 ? 255 : (v < 0 ? 0 : v));
      dstPixels[i + 1] = ((v = srcPixels[i + 1] * greenMultiplier + greenOffset) > 255 ? 255 : (v < 0 ? 0 : v));
      dstPixels[i + 2] = ((v = srcPixels[i + 2] * blueMultiplier + blueOffset) > 255 ? 255 : (v < 0 ? 0 : v));
      dstPixels[i + 3] = ((v = srcPixels[i + 3] * alphaMultiplier + alphaOffset) > 255 ? 255 : (v < 0 ? 0 : v));
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.Copy = function(srcImageData, dstImageData) {
    var dstPixels, srcLength, srcPixels;
    srcPixels = srcImageData.data;
    srcLength = srcPixels.length;
    dstPixels = dstImageData.data;
    while (srcLength--) {
      dstPixels[srcLength] = srcPixels[srcLength];
    }
    return dstImageData;
  };

  ImageFilters.Crop = function(srcImageData, x, y, width, height) {
    var dstCol, dstImageData, dstIndex, dstLeft, dstPixels, dstRow, dstTop, srcBottom, srcCol, srcHeight, srcIndex, srcLeft, srcLength, srcPixels, srcRight, srcRow, srcTop, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(width, height);
    dstPixels = dstImageData.data;
    srcLeft = Math.max(x, 0);
    srcTop = Math.max(y, 0);
    srcRight = Math.min(x + width, srcWidth);
    srcBottom = Math.min(y + height, srcHeight);
    dstLeft = srcLeft - x;
    dstTop = srcTop - y;
    srcRow = void 0;
    srcCol = void 0;
    srcIndex = void 0;
    dstIndex = void 0;
    srcRow = srcTop;
    dstRow = dstTop;
    while (srcRow < srcBottom) {
      srcCol = srcLeft;
      dstCol = dstLeft;
      while (srcCol < srcRight) {
        srcIndex = (srcRow * srcWidth + srcCol) << 2;
        dstIndex = (dstRow * width + dstCol) << 2;
        dstPixels[dstIndex] = srcPixels[srcIndex];
        dstPixels[dstIndex + 1] = srcPixels[srcIndex + 1];
        dstPixels[dstIndex + 2] = srcPixels[srcIndex + 2];
        dstPixels[dstIndex + 3] = srcPixels[srcIndex + 3];
        srcCol += 1;
        dstCol += 1;
      }
      srcRow += 1;
      dstRow += 1;
    }
    return dstImageData;
  };

  ImageFilters.CropBuiltin = function(srcImageData, x, y, width, height) {
    var canvas, context, result, srcHeight, srcWidth;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    canvas = this.utils.getSampleCanvas();
    context = this.utils.getSampleContext();
    canvas.width = srcWidth;
    canvas.height = srcHeight;
    context.putImageData(srcImageData, 0, 0);
    result = context.getImageData(x, y, width, height);
    canvas.width = 0;
    canvas.height = 0;
    return result;
  };

  ImageFilters.Desaturate = function(srcImageData) {
    var avg, b, dstImageData, dstPixels, g, i, max, min, r, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    i = 0;
    while (i < srcLength) {
      r = srcPixels[i];
      g = srcPixels[i + 1];
      b = srcPixels[i + 2];
      max = (r > g ? (r > b ? r : b) : (g > b ? g : b));
      min = (r < g ? (r < b ? r : b) : (g < b ? g : b));
      avg = ((max + min) / 2) + 0.5 | 0;
      dstPixels[i] = dstPixels[i + 1] = dstPixels[i + 2] = avg;
      dstPixels[i + 3] = srcPixels[i + 3];
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.DisplacementMapFilter = function(srcImageData, mapImageData, mapX, mapY, componentX, componentY, scaleX, scaleY, mode) {
    var cx, cy, dstImageData, dstIndex, dstPixels, mapBottom, mapHeight, mapIndex, mapPixels, mapRight, mapWidth, srcHeight, srcIndex, srcLength, srcPixels, srcWidth, tx, ty, x, y;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = ImageFilters.Clone(srcImageData);
    dstPixels = dstImageData.data;
    mapX || (mapX = 0);
    mapY || (mapY = 0);
    componentX || (componentX = 0);
    componentY || (componentY = 0);
    scaleX || (scaleX = 0);
    scaleY || (scaleY = 0);
    mode || (mode = 2);
    mapWidth = mapImageData.width;
    mapHeight = mapImageData.height;
    mapPixels = mapImageData.data;
    mapRight = mapWidth + mapX;
    mapBottom = mapHeight + mapY;
    dstIndex = void 0;
    srcIndex = void 0;
    mapIndex = void 0;
    cx = void 0;
    cy = void 0;
    tx = void 0;
    ty = void 0;
    x = void 0;
    y = void 0;
    x = 0;
    while (x < srcWidth) {
      y = 0;
      while (y < srcHeight) {
        dstIndex = (y * srcWidth + x) << 2;
        if (x < mapX || y < mapY || x >= mapRight || y >= mapBottom) {
          srcIndex = dstIndex;
        } else {
          mapIndex = (y - mapY) * mapWidth + (x - mapX) << 2;
          cx = mapPixels[mapIndex + componentX];
          tx = x + (((cx - 128) * scaleX) >> 8);
          cy = mapPixels[mapIndex + componentY];
          ty = y + (((cy - 128) * scaleY) >> 8);
          srcIndex = ImageFilters.utils.getPixelIndex(tx + 0.5 | 0, ty + 0.5 | 0, srcWidth, srcHeight, mode);
          if (srcIndex === null) {
            srcIndex = dstIndex;
          }
        }
        dstPixels[dstIndex] = srcPixels[srcIndex];
        dstPixels[dstIndex + 1] = srcPixels[srcIndex + 1];
        dstPixels[dstIndex + 2] = srcPixels[srcIndex + 2];
        dstPixels[dstIndex + 3] = srcPixels[srcIndex + 3];
        y += 1;
      }
      x += 1;
    }
    return dstImageData;
  };

  ImageFilters.Dither = function(srcImageData, levels) {
    var A, B, C, D, dstImageData, dstPixels, err_b, err_g, err_r, i, index, j, k, levelMap, levelsMinus1, nbr_b, nbr_g, nbr_r, new_b, new_g, new_r, old_b, old_g, old_r, posterize, srcHeight, srcHeightMinus1, srcWidth, srcWidthMinus1, x, y;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    dstImageData = this.Clone(srcImageData);
    dstPixels = dstImageData.data;
    levels = (levels < 2 ? 2 : (levels > 255 ? 255 : levels));
    posterize = void 0;
    levelMap = [];
    levelsMinus1 = levels - 1;
    j = 0;
    k = 0;
    i = void 0;
    i = 0;
    while (i < levels) {
      levelMap[i] = (255 * i) / levelsMinus1;
      i += 1;
    }
    posterize = this.utils.buildMap(function(value) {
      var ret;
      ret = levelMap[j];
      k += levels;
      if (k > 255) {
        k -= 255;
        j += 1;
      }
      return ret;
    });
    x = void 0;
    y = void 0;
    index = void 0;
    old_r = void 0;
    old_g = void 0;
    old_b = void 0;
    new_r = void 0;
    new_g = void 0;
    new_b = void 0;
    err_r = void 0;
    err_g = void 0;
    err_b = void 0;
    nbr_r = void 0;
    nbr_g = void 0;
    nbr_b = void 0;
    srcWidthMinus1 = srcWidth - 1;
    srcHeightMinus1 = srcHeight - 1;
    A = 7 / 16;
    B = 3 / 16;
    C = 5 / 16;
    D = 1 / 16;
    y = 0;
    while (y < srcHeight) {
      x = 0;
      while (x < srcWidth) {
        index = (y * srcWidth + x) << 2;
        old_r = dstPixels[index];
        old_g = dstPixels[index + 1];
        old_b = dstPixels[index + 2];
        new_r = posterize[old_r];
        new_g = posterize[old_g];
        new_b = posterize[old_b];
        dstPixels[index] = new_r;
        dstPixels[index + 1] = new_g;
        dstPixels[index + 2] = new_b;
        err_r = old_r - new_r;
        err_g = old_g - new_g;
        err_b = old_b - new_b;
        index += 1 << 2;
        if (x < srcWidthMinus1) {
          nbr_r = dstPixels[index] + A * err_r;
          nbr_g = dstPixels[index + 1] + A * err_g;
          nbr_b = dstPixels[index + 2] + A * err_b;
          dstPixels[index] = (nbr_r > 255 ? 255 : (nbr_r < 0 ? 0 : nbr_r | 0));
          dstPixels[index + 1] = (nbr_g > 255 ? 255 : (nbr_g < 0 ? 0 : nbr_g | 0));
          dstPixels[index + 2] = (nbr_b > 255 ? 255 : (nbr_b < 0 ? 0 : nbr_b | 0));
        }
        index += (srcWidth - 2) << 2;
        if (x > 0 && y < srcHeightMinus1) {
          nbr_r = dstPixels[index] + B * err_r;
          nbr_g = dstPixels[index + 1] + B * err_g;
          nbr_b = dstPixels[index + 2] + B * err_b;
          dstPixels[index] = (nbr_r > 255 ? 255 : (nbr_r < 0 ? 0 : nbr_r | 0));
          dstPixels[index + 1] = (nbr_g > 255 ? 255 : (nbr_g < 0 ? 0 : nbr_g | 0));
          dstPixels[index + 2] = (nbr_b > 255 ? 255 : (nbr_b < 0 ? 0 : nbr_b | 0));
        }
        index += 1 << 2;
        if (y < srcHeightMinus1) {
          nbr_r = dstPixels[index] + C * err_r;
          nbr_g = dstPixels[index + 1] + C * err_g;
          nbr_b = dstPixels[index + 2] + C * err_b;
          dstPixels[index] = (nbr_r > 255 ? 255 : (nbr_r < 0 ? 0 : nbr_r | 0));
          dstPixels[index + 1] = (nbr_g > 255 ? 255 : (nbr_g < 0 ? 0 : nbr_g | 0));
          dstPixels[index + 2] = (nbr_b > 255 ? 255 : (nbr_b < 0 ? 0 : nbr_b | 0));
        }
        index += 1 << 2;
        if (x < srcWidthMinus1 && y < srcHeightMinus1) {
          nbr_r = dstPixels[index] + D * err_r;
          nbr_g = dstPixels[index + 1] + D * err_g;
          nbr_b = dstPixels[index + 2] + D * err_b;
          dstPixels[index] = (nbr_r > 255 ? 255 : (nbr_r < 0 ? 0 : nbr_r | 0));
          dstPixels[index + 1] = (nbr_g > 255 ? 255 : (nbr_g < 0 ? 0 : nbr_g | 0));
          dstPixels[index + 2] = (nbr_b > 255 ? 255 : (nbr_b < 0 ? 0 : nbr_b | 0));
        }
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.Edge = function(srcImageData) {
    return ImageFilters.ConvolutionFilter(srcImageData, 3, 3, [-1, -1, -1, -1, 8, -1, -1, -1, -1]);
  };

  ImageFilters.Emboss = function(srcImageData) {
    return ImageFilters.ConvolutionFilter(srcImageData, 3, 3, [-2, -1, 0, -1, 1, 1, 0, 1, 2]);
  };

  ImageFilters.Enrich = function(srcImageData) {
    return ImageFilters.ConvolutionFilter(srcImageData, 3, 3, [0, -2, 0, -2, 20, -2, 0, -2, 0], 10, -40);
  };

  ImageFilters.Flip = function(srcImageData, vertical) {
    var dstImageData, dstIndex, dstPixels, i, srcHeight, srcIndex, srcLength, srcPixels, srcWidth, x, y;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    x = void 0;
    y = void 0;
    srcIndex = void 0;
    dstIndex = void 0;
    i = void 0;
    y = 0;
    while (y < srcHeight) {
      x = 0;
      while (x < srcWidth) {
        srcIndex = (y * srcWidth + x) << 2;
        if (vertical) {
          dstIndex = ((srcHeight - y - 1) * srcWidth + x) << 2;
        } else {
          dstIndex = (y * srcWidth + (srcWidth - x - 1)) << 2;
        }
        dstPixels[dstIndex] = srcPixels[srcIndex];
        dstPixels[dstIndex + 1] = srcPixels[srcIndex + 1];
        dstPixels[dstIndex + 2] = srcPixels[srcIndex + 2];
        dstPixels[dstIndex + 3] = srcPixels[srcIndex + 3];
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.Gamma = function(srcImageData, gamma) {
    var dstImageData, dstPixels, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      value = 255 * Math.pow(value / 255, 1 / gamma) + 0.5;
      if (value > 255) {
        return 255;
      } else {
        return value + 0.5 | 0;
      }
    });
    return dstImageData;
  };

  ImageFilters.GrayScale = function(srcImageData) {
    var dstImageData, dstPixels, i, intensity, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    i = 0;
    while (i < srcLength) {
      intensity = (srcPixels[i] * 19595 + srcPixels[i + 1] * 38470 + srcPixels[i + 2] * 7471) >> 16;
      dstPixels[i] = dstPixels[i + 1] = dstPixels[i + 2] = intensity;
      dstPixels[i + 3] = srcPixels[i + 3];
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.HSLAdjustment = function(srcImageData, hueDelta, satDelta, lightness) {
    var dstImageData, dstPixels, h, hsl, hslToRgb, i, l, rgb, rgbToHsl, s, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    hueDelta /= 360;
    satDelta /= 100;
    lightness /= 100;
    rgbToHsl = this.utils.rgbToHsl;
    hslToRgb = this.utils.hslToRgb;
    h = void 0;
    s = void 0;
    l = void 0;
    hsl = void 0;
    rgb = void 0;
    i = void 0;
    i = 0;
    while (i < srcLength) {
      hsl = rgbToHsl(srcPixels[i], srcPixels[i + 1], srcPixels[i + 2]);
      h = hsl[0] + hueDelta;
      while (h < 0) {
        h += 1;
      }
      while (h > 1) {
        h -= 1;
      }
      s = hsl[1] + hsl[1] * satDelta;
      if (s < 0) {
        s = 0;
      } else {
        if (s > 1) {
          s = 1;
        }
      }
      l = hsl[2];
      if (lightness > 0) {
        l += (1 - l) * lightness;
      } else {
        if (lightness < 0) {
          l += l * lightness;
        }
      }
      rgb = hslToRgb(h, s, l);
      dstPixels[i] = rgb[0];
      dstPixels[i + 1] = rgb[1];
      dstPixels[i + 2] = rgb[2];
      dstPixels[i + 3] = srcPixels[i + 3];
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.Invert = function(srcImageData) {
    var dstImageData, dstPixels, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      return 255 - value;
    });
    return dstImageData;
  };

  ImageFilters.Mosaic = function(srcImageData, blockSize) {
    var a, b, col, cols, dstImageData, dstPixels, g, index, r, row, rows, size, srcHeight, srcLength, srcPixels, srcWidth, x, x_end, x_start, y, yIndex, y_end, y_start;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    cols = Math.ceil(srcWidth / blockSize);
    rows = Math.ceil(srcHeight / blockSize);
    row = void 0;
    col = void 0;
    x_start = void 0;
    x_end = void 0;
    y_start = void 0;
    y_end = void 0;
    x = void 0;
    y = void 0;
    yIndex = void 0;
    index = void 0;
    size = void 0;
    r = void 0;
    g = void 0;
    b = void 0;
    a = void 0;
    row = 0;
    while (row < rows) {
      y_start = row * blockSize;
      y_end = y_start + blockSize;
      if (y_end > srcHeight) {
        y_end = srcHeight;
      }
      col = 0;
      while (col < cols) {
        x_start = col * blockSize;
        x_end = x_start + blockSize;
        if (x_end > srcWidth) {
          x_end = srcWidth;
        }
        r = g = b = a = 0;
        size = (x_end - x_start) * (y_end - y_start);
        y = y_start;
        while (y < y_end) {
          yIndex = y * srcWidth;
          x = x_start;
          while (x < x_end) {
            index = (yIndex + x) << 2;
            r += srcPixels[index];
            g += srcPixels[index + 1];
            b += srcPixels[index + 2];
            a += srcPixels[index + 3];
            x += 1;
          }
          y += 1;
        }
        r = (r / size) + 0.5 | 0;
        g = (g / size) + 0.5 | 0;
        b = (b / size) + 0.5 | 0;
        a = (a / size) + 0.5 | 0;
        y = y_start;
        while (y < y_end) {
          yIndex = y * srcWidth;
          x = x_start;
          while (x < x_end) {
            index = (yIndex + x) << 2;
            dstPixels[index] = r;
            dstPixels[index + 1] = g;
            dstPixels[index + 2] = b;
            dstPixels[index + 3] = a;
            x += 1;
          }
          y += 1;
        }
        col += 1;
      }
      row += 1;
    }
    return dstImageData;
  };

  ImageFilters.Oil = function(srcImageData, range, levels) {
    var b, bh, bi, bt, col, colIndex, dstImageData, dstPixels, g, gh, gi, gt, i, index, offset, r, rh, ri, row, rowIndex, rt, sb, sg, sr, srcHeight, srcIndex, srcLength, srcPixels, srcWidth, x, y;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    index = 0;
    rh = [];
    gh = [];
    bh = [];
    rt = [];
    gt = [];
    bt = [];
    x = void 0;
    y = void 0;
    i = void 0;
    row = void 0;
    col = void 0;
    rowIndex = void 0;
    colIndex = void 0;
    offset = void 0;
    srcIndex = void 0;
    sr = void 0;
    sg = void 0;
    sb = void 0;
    ri = void 0;
    gi = void 0;
    bi = void 0;
    r = void 0;
    g = void 0;
    b = void 0;
    y = 0;
    while (y < srcHeight) {
      x = 0;
      while (x < srcWidth) {
        i = 0;
        while (i < levels) {
          rh[i] = gh[i] = bh[i] = rt[i] = gt[i] = bt[i] = 0;
          i += 1;
        }
        row = -range;
        while (row <= range) {
          rowIndex = y + row;
          if (rowIndex < 0 || rowIndex >= srcHeight) {
            continue;
          }
          offset = rowIndex * srcWidth;
          col = -range;
          while (col <= range) {
            colIndex = x + col;
            if (colIndex < 0 || colIndex >= srcWidth) {
              continue;
            }
            srcIndex = (offset + colIndex) << 2;
            sr = srcPixels[srcIndex];
            sg = srcPixels[srcIndex + 1];
            sb = srcPixels[srcIndex + 2];
            ri = (sr * levels) >> 8;
            gi = (sg * levels) >> 8;
            bi = (sb * levels) >> 8;
            rt[ri] += sr;
            gt[gi] += sg;
            bt[bi] += sb;
            rh[ri] += 1;
            gh[gi] += 1;
            bh[bi] += 1;
            col += 1;
          }
          row += 1;
        }
        r = g = b = 0;
        i = 1;
        while (i < levels) {
          if (rh[i] > rh[r]) {
            r = i;
          }
          if (gh[i] > gh[g]) {
            g = i;
          }
          if (bh[i] > bh[b]) {
            b = i;
          }
          i += 1;
        }
        dstPixels[index] = rt[r] / rh[r] | 0;
        dstPixels[index + 1] = gt[g] / gh[g] | 0;
        dstPixels[index + 2] = bt[b] / bh[b] | 0;
        dstPixels[index + 3] = srcPixels[index + 3];
        index += 4;
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.OpacityFilter = function(srcImageData, opacity) {
    var dstImageData, dstPixels, i, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    i = 0;
    while (i < srcLength) {
      dstPixels[i] = srcPixels[i];
      dstPixels[i + 1] = srcPixels[i + 1];
      dstPixels[i + 2] = srcPixels[i + 2];
      dstPixels[i + 3] = opacity;
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.Posterize = function(srcImageData, levels) {
    var dstImageData, dstPixels, i, j, k, levelMap, levelsMinus1, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    levels = (levels < 2 ? 2 : (levels > 255 ? 255 : levels));
    levelMap = [];
    levelsMinus1 = levels - 1;
    j = 0;
    k = 0;
    i = void 0;
    i = 0;
    while (i < levels) {
      levelMap[i] = (255 * i) / levelsMinus1;
      i += 1;
    }
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      var ret;
      ret = levelMap[j];
      k += levels;
      if (k > 255) {
        k -= 255;
        j += 1;
      }
      return ret;
    });
    return dstImageData;
  };

  ImageFilters.Rescale = function(srcImageData, scale) {
    var dstImageData, dstPixels, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      value *= scale;
      if (value > 255) {
        return 255;
      } else {
        return value + 0.5 | 0;
      }
    });
    return dstImageData;
  };

  ImageFilters.ResizeNearestNeighbor = function(srcImageData, width, height) {
    var dstImageData, dstIndex, dstPixels, offset, srcHeight, srcIndex, srcLength, srcPixels, srcWidth, x, xFactor, y, yFactor;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(width, height);
    dstPixels = dstImageData.data;
    xFactor = srcWidth / width;
    yFactor = srcHeight / height;
    dstIndex = 0;
    srcIndex = void 0;
    x = void 0;
    y = void 0;
    offset = void 0;
    y = 0;
    while (y < height) {
      offset = ((y * yFactor) | 0) * srcWidth;
      x = 0;
      while (x < width) {
        srcIndex = (offset + x * xFactor) << 2;
        dstPixels[dstIndex] = srcPixels[srcIndex];
        dstPixels[dstIndex + 1] = srcPixels[srcIndex + 1];
        dstPixels[dstIndex + 2] = srcPixels[srcIndex + 2];
        dstPixels[dstIndex + 3] = srcPixels[srcIndex + 3];
        dstIndex += 4;
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.Resize = function(srcImageData, width, height) {
    var dstImageData, dstIndex, dstPixels, srcHeight, srcLength, srcPixels, srcWidth, x, xFactor, y, yFactor;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(width, height);
    dstPixels = dstImageData.data;
    xFactor = srcWidth / width;
    yFactor = srcHeight / height;
    dstIndex = 0;
    x = void 0;
    y = void 0;
    y = 0;
    while (y < height) {
      x = 0;
      while (x < width) {
        this.utils.copyBilinear(srcPixels, x * xFactor, y * yFactor, srcWidth, srcHeight, dstPixels, dstIndex, 0);
        dstIndex += 4;
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.ResizeBuiltin = function(srcImageData, width, height) {
    var canvas, context, dstImageData, srcHeight, srcWidth;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    canvas = this.utils.getSampleCanvas();
    context = this.utils.getSampleContext();
    dstImageData = void 0;
    canvas.width = Math.max(srcWidth, width);
    canvas.height = Math.max(srcHeight, height);
    context.save();
    context.putImageData(srcImageData, 0, 0);
    context.scale(width / srcWidth, height / srcHeight);
    context.drawImage(canvas, 0, 0);
    dstImageData = context.getImageData(0, 0, width, height);
    context.restore();
    canvas.width = 0;
    canvas.height = 0;
    return dstImageData;
  };

  ImageFilters.Sepia = function(srcImageData) {
    var b, dstImageData, dstPixels, g, i, r, srcHeight, srcLength, srcPixels, srcWidth, value;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    r = void 0;
    g = void 0;
    b = void 0;
    i = void 0;
    value = void 0;
    i = 0;
    while (i < srcLength) {
      r = srcPixels[i];
      g = srcPixels[i + 1];
      b = srcPixels[i + 2];
      dstPixels[i] = ((value = r * 0.393 + g * 0.769 + b * 0.189) > 255 ? 255 : (value < 0 ? 0 : value + 0.5 | 0));
      dstPixels[i + 1] = ((value = r * 0.349 + g * 0.686 + b * 0.168) > 255 ? 255 : (value < 0 ? 0 : value + 0.5 | 0));
      dstPixels[i + 2] = ((value = r * 0.272 + g * 0.534 + b * 0.131) > 255 ? 255 : (value < 0 ? 0 : value + 0.5 | 0));
      dstPixels[i + 3] = srcPixels[i + 3];
      i += 4;
    }
    return dstImageData;
  };

  ImageFilters.Sharpen = function(srcImageData, factor) {
    return ImageFilters.ConvolutionFilter(srcImageData, 3, 3, [-factor / 16, -factor / 8, -factor / 16, -factor / 8, factor * 0.75 + 1, -factor / 8, -factor / 16, -factor / 8, -factor / 16]);
  };

  ImageFilters.Solarize = function(srcImageData) {
    var dstImageData, dstPixels, srcHeight, srcLength, srcPixels, srcWidth;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    this.utils.mapRGB(srcPixels, dstPixels, function(value) {
      if (value > 127) {
        return (value - 127.5) * 2;
      } else {
        return (127.5 - value) * 2;
      }
    });
    return dstImageData;
  };

  ImageFilters.Transpose = function(srcImageData) {
    var dstImageData, dstIndex, dstPixels, srcHeight, srcIndex, srcLength, srcPixels, srcWidth, x, y;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcHeight, srcWidth);
    dstPixels = dstImageData.data;
    srcIndex = void 0;
    dstIndex = void 0;
    y = 0;
    while (y < srcHeight) {
      x = 0;
      while (x < srcWidth) {
        srcIndex = (y * srcWidth + x) << 2;
        dstIndex = (x * srcHeight + y) << 2;
        dstPixels[dstIndex] = srcPixels[srcIndex];
        dstPixels[dstIndex + 1] = srcPixels[srcIndex + 1];
        dstPixels[dstIndex + 2] = srcPixels[srcIndex + 2];
        dstPixels[dstIndex + 3] = srcPixels[srcIndex + 3];
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  ImageFilters.Twril = function(srcImageData, centerX, centerY, radius, angle, edge, smooth) {
    var a, distance, dstImageData, dstIndex, dstPixels, dx, dy, i, max_x, max_y, pixel, radius2, srcHeight, srcIndex, srcLength, srcPixels, srcWidth, tx, ty, x, y;
    srcPixels = srcImageData.data;
    srcWidth = srcImageData.width;
    srcHeight = srcImageData.height;
    srcLength = srcPixels.length;
    dstImageData = this.utils.createImageData(srcWidth, srcHeight);
    dstPixels = dstImageData.data;
    centerX = srcWidth * centerX;
    centerY = srcHeight * centerY;
    angle *= Math.PI / 180;
    radius2 = radius * radius;
    max_y = srcHeight - 1;
    max_x = srcWidth - 1;
    dstIndex = 0;
    x = void 0;
    y = void 0;
    dx = void 0;
    dy = void 0;
    distance = void 0;
    a = void 0;
    tx = void 0;
    ty = void 0;
    srcIndex = void 0;
    pixel = void 0;
    i = void 0;
    y = 0;
    while (y < srcHeight) {
      x = 0;
      while (x < srcWidth) {
        dx = x - centerX;
        dy = y - centerY;
        distance = dx * dx + dy * dy;
        if (distance > radius2) {
          dstPixels[dstIndex] = srcPixels[dstIndex];
          dstPixels[dstIndex + 1] = srcPixels[dstIndex + 1];
          dstPixels[dstIndex + 2] = srcPixels[dstIndex + 2];
          dstPixels[dstIndex + 3] = srcPixels[dstIndex + 3];
        } else {
          distance = Math.sqrt(distance);
          a = Math.atan2(dy, dx) + (angle * (radius - distance)) / radius;
          tx = centerX + distance * Math.cos(a);
          ty = centerY + distance * Math.sin(a);
          if (smooth) {
            this.utils.copyBilinear(srcPixels, tx, ty, srcWidth, srcHeight, dstPixels, dstIndex, edge);
          } else {
            srcIndex = (ty + 0.5 | 0) * srcWidth + (tx + 0.5 | 0) << 2;
            dstPixels[dstIndex] = srcPixels[srcIndex];
            dstPixels[dstIndex + 1] = srcPixels[srcIndex + 1];
            dstPixels[dstIndex + 2] = srcPixels[srcIndex + 2];
            dstPixels[dstIndex + 3] = srcPixels[srcIndex + 3];
          }
        }
        dstIndex += 4;
        x += 1;
      }
      y += 1;
    }
    return dstImageData;
  };

  _DEBUG_ = true;

  dlog = function(msg) {
    if (_DEBUG_) {
      return console.log(msg);
    }
  };

  nb = function() {
    var cb, p;
    cb = arguments[0], p = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    if (cb) {
      window.setTimeout.apply(window, [cb, 0].concat(__slice.call(p)));
    }
    return p[0];
  };

  clamp = function(v, min, max) {
    if (min == null) {
      min = 0;
    }
    if (max == null) {
      max = 255;
    }
    return Math.min(max, Math.max(min, v));
  };

  getToolbox = function(c) {
    var ctx, img_data;
    return [ctx = c.getContext('2d'), img_data = ctx.getImageData(0, 0, c.width, c.height), img_data.data];
  };

  make = function(width, height) {
    var c, element;
    if (width == null) {
      width = 800;
    }
    if (height == null) {
      height = 600;
    }
    if (width.width && width.height) {
      element = width;
      width = element.width;
      height = element.height;
    }
    c = document.createElement('canvas');
    c.width = width;
    c.height = height;
    return c;
  };

  newToolbox = function(width, height) {
    return getToolbox(make(width, height));
  };

  copy = function(c, cb) {
    var new_c, new_ctx, _ref;
    _ref = newToolbox(c), new_c = _ref[0], new_ctx = _ref[1];
    ctx.drawImage(c, 0, 0, c.width, c.height);
    return nb(cb, new_c);
  };

  byImage = function(img, cb) {
    if (img.width && img.height) {
      return copy(img, cb);
    } else {
      img.onload(function() {
        return byImage(img, cb);
      });
      return false;
    }
  };

  byArray = function(a, w, h, cb) {
    var c, ctx, i, imgd, px, _ref;
    _ref = newToolbox(w, h), c = _ref[0], ctx = _ref[1], imgd = _ref[2], px = _ref[3];
    i = 0;
    while (i < px.length) {
      cx[i] = a[i];
      i = i + 1;
    }
    ctx.putImageData(img, 0, 0);
    return nb(cb, c);
  };

  rotateRight = function(c, cb) {
    var new_c, new_ctx, _ref;
    _ref = newToolbox(c), new_c = _ref[0], new_ctx = _ref[1];
    new_ctx.rotate(90 * Math.PI / 180);
    new_ctx.drawImage(c, 0, c.height * -1);
    return nb(cb, c);
  };

  rotateLeft = function(c, cb) {
    var new_c, new_ctx, _ref;
    _ref = newToolbox(c), new_c = _ref[0], new_ctx = _ref[1];
    new_ctx.rotate(-90 * Math.PI / 180);
    new_ctx.drawImage(c, c.width * -1, 0);
    return nb(cb, c);
  };

  flip = function(c, cb) {
    var new_c, new_ctx, _ref;
    _ref = newToolbox(c), new_c = _ref[0], new_ctx = _ref[1];
    new_ctx.rotate(Math.PI);
    new_ctx.drawImage(c, c.width * -1, c.height * -1);
    return nb(cb, c);
  };

  mirror = function(c, cb) {
    var new_c, new_ctx, _ref;
    _ref = newToolbox(c), new_c = _ref[0], new_ctx = _ref[1];
    new_ctx.translate(c2.width / 2, 0);
    new_ctx.scale(-1, 1);
    new_ctx.drawImage(c, (c2.width / 2) * -1, 0);
    return nb(cb, c);
  };

  ifw = function() {
    var c, cb, ctx, image_filters_func, imgd, new_c, new_ctx, new_imgd, new_px, p, px, _ref, _ref1;
    c = arguments[0], cb = arguments[1], image_filters_func = arguments[2], p = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
    _ref = getToolbox(c), c = _ref[0], ctx = _ref[1], imgd = _ref[2], px = _ref[3];
    _ref1 = newToolbox(c), new_c = _ref1[0], new_ctx = _ref1[1], new_imgd = _ref1[2], new_px = _ref1[3];
    nb(function() {
      return new_ctx.putImageData(image_filters_func.apply(null, [imgd].concat(__slice.call(p))), 0, 0);
    });
    return nb(cb, new_c);
  };

  binarize = function(c, cb, threshold) {
    if (threshold == null) {
      threshold = 0.5;
    }
    return ifb(c, ImageFilters.Binarize, cb, threshold);
  };

}).call(this);
